variable = c("rakhi" , "christmas"),
category = c("a", "a"),
calc = c("", "")
)
# run model
pooled_model = run_model(
verbose = FALSE,
data = pooled_data,
dv = pooled_dv,
meta_data =  pooled_meta_data,
model_table = pooled_model_table,
normalise_by_pool = TRUE
)
# tests  ####
model %>%
what_next()
run_model(data = mtcars,dv = 'mpg',ivs = c('disp','cyl')) %>%
what_trans(variable = 'cyl',trans_df = data.frame(
name = c('diminish', 'decay', 'lag', 'ma', 'log', 'hill', 'sin', 'exp'),
func = c('linea::diminish(x,a)',
'linea::decay(x,a)',
'linea::lag(x,a)',
'linea::ma(x,a)',
'log(x,a)',
"linea::hill_function(x,a,b,c)",
'sin(x*a)',
'(x^a)'),order = 1:8) %>%
dplyr::mutate(val = '') %>%
dplyr::mutate(val = dplyr::if_else(condition = name == 'hill',
'(1,5,50),(1 ,5,50),(1,5,50)',
val)))
what_trans
linea::vapply_transformation()
linea::vapply_transformation
model
trans_df = NULL
variable = NULL
data = NULL
r2_diff = TRUE
verbose = FALSE
if (!is.logical(verbose)) {
cat("Warning: verbose provided mus be logical (TRUE or FALSE). Setting to False. \n")
verbose = FALSE
}
if (!is.logical(r2_diff)) {
if (verbose)
cat("Warning: r2_diff provided mus be logical (TRUE or FALSE). Setting to TRUE. \n")
r2_diff = TRUE
}
if (is.null(trans_df)) {
cat("Error: trans_df must be provided. Returning NULL. \n")
return(NULL)
}
if (is.null(variable)) {
cat("Error: variable must be provided. Returning NULL. \n")
return(NULL)
}
trans_df = data.frame(
name = c('diminish', 'decay', 'lag', 'ma', 'log', 'hill', 'sin', 'exp'),
func = c('linea::diminish(x,a)',
'linea::decay(x,a)',
'linea::lag(x,a)',
'linea::ma(x,a)',
'log(x,a)',
"linea::hill_function(x,a,b,c)",
'sin(x*a)',
'(x^a)'),order = 1:8) %>%
dplyr::mutate(val = '') %>%
dplyr::mutate(val = dplyr::if_else(condition = name == 'hill',
'(1,5,50),(1 ,5,50),(1,5,50)',
val))
library(dplyr)
trans_df = data.frame(
name = c('diminish', 'decay', 'lag', 'ma', 'log', 'hill', 'sin', 'exp'),
func = c('linea::diminish(x,a)',
'linea::decay(x,a)',
'linea::lag(x,a)',
'linea::ma(x,a)',
'log(x,a)',
"linea::hill_function(x,a,b,c)",
'sin(x*a)',
'(x^a)'),order = 1:8) %>%
dplyr::mutate(val = '') %>%
dplyr::mutate(val = dplyr::if_else(condition = name == 'hill',
'(1,5,50),(1 ,5,50),(1,5,50)',
val))
model$data
variable = ''
trans_df = data.frame(
name = c('diminish', 'decay', 'lag', 'ma', 'log', 'hill', 'sin', 'exp'),
func = c('linea::diminish(x,a)',
'linea::decay(x,a)',
'linea::lag(x,a)',
'linea::ma(x,a)',
'log(x,a)',
"linea::hill_function(x,a,b,c)",
'sin(x*a)',
'(x^a)'),order = 1:8) %>%
dplyr::mutate(val = '') %>%
dplyr::mutate(val = dplyr::if_else(condition = name == 'hill',
'(1,5,50),(1 ,5,50),(1,5,50)',
val))
variable = 'cyl'
model = run_model(data = mtcars,dv = 'mpg',ivs = c('disp','cyl'))
data = NULL
model = linea::run_model(data = mtcars,dv = 'mpg',ivs = c('disp','cyl'))
data = NULL
r2_diff = TRUE
verbose = FALSE
if (!is.logical(verbose)) {
cat("Warning: verbose provided mus be logical (TRUE or FALSE). Setting to False. \n")
verbose = FALSE
}
if (!is.logical(r2_diff)) {
if (verbose)
cat("Warning: r2_diff provided mus be logical (TRUE or FALSE). Setting to TRUE. \n")
r2_diff = TRUE
}
if (is.null(trans_df)) {
cat("Error: trans_df must be provided. Returning NULL. \n")
return(NULL)
}
if (is.null(variable)) {
cat("Error: variable must be provided. Returning NULL. \n")
return(NULL)
}
# check if model or model_table is provided is correct
if (is.null(model)) {
if (is.null(model_table)) {
cat("Error: no model or model_table provided. Returning NULL. \n")
return(NULL)
}
} else{
if (class(model) != "lm") {
cat("\n Error: model must be of type 'lm'. Returning NULL.")
return(NULL)
}
else{
if (!('dv' %in% names(model))) {
cat("\n Error: model object must contain 'dv'. Returning NULL.")
return(NULL)
} else{
dv = model$dv
}
if (!('model_table' %in% names(model))) {
cat("\n Error: model object must contain 'model_table'. Returning NULL.")
return(NULL)
} else{
model_table = model$model_table
}
}
}
# check data
if (is.null(data)) {
data = model$data
if (is.null(data)) {
cat('Error: no data provided as data or in model. \n')
}
}
# check pool
if (model$normalise_by_pool) {
meta_data = model$meta_data
pool = meta_data$variable[toupper(meta_data$meta) == 'POOL']
groups = data %>%
pull(!!sym(pool)) %>%
unique()
data = apply_normalisation(
raw_data = data,
# model_table =  model$model_table,
meta_data = model$meta_data,
dv = model$dv,
verbose = verbose
)
# check norm_data
if (length(data) == 2) {
pool_mean = data$pool_mean
data = data$data
}
}
data = apply_transformation(
data = data,
model_table = model$model_table,
trans_df = model$trans_df,
meta_data = model$meta_data,
verbose = verbose
)
library(linea)
data = apply_transformation(
data = data,
model_table = model$model_table,
trans_df = model$trans_df,
meta_data = model$meta_data,
verbose = verbose
)
apply_transformation
# clean trans_df
trans_df = trans_df %>%
mutate(val = gsub(
pattern = ' ',
replacement = '',
x = val
)) %>%
filter(val != "")
# split values by parameter (for func's with +2 params)
ncols = max(stringr::str_count(trans_df$val, "\\),\\(")) + 1
cols = letters[1:ncols]
trans_df = tidyr::separate(
fill = 'right',
data = trans_df,
col = 'val',
into = cols,
sep = "\\).\\("
) %>%
zoo::na.fill('') %>%
as.data.frame() %>%
reshape2::melt(id.vars = c('name', 'order', 'func'),
factorsAsStrings = FALSE) %>%
filter(value != '')  %>%
mutate(value = gsub(
pattern = '\\(|\\)',
replacement = '',
x = value
))
# split each parameter (to be tested)
ncols = max(stringr::str_count(trans_df$value, ",")) + 1
cols = paste0('param_', 1:ncols)
trans_df = trans_df %>%
tidyr::separate(
fill = 'right',
col = 'value',
into = cols,
sep = ","
) %>%
zoo::na.fill('') %>%
as.data.frame()
# get all combinations
df = lapply(1:nrow(trans_df), function(x) {
v = trans_df[x, ] %>%
as.vector()
v = v[5:length(v)]
v = as.numeric(v[v != ''])
return(v)
}) %>%
expand.grid() %>%
zoo::na.fill('') %>%
as.data.frame()
# rename combinations
colnames(df) = paste0(trans_df$name, '_', trans_df$variable)
# define output table to fill with loop
df = cbind(df, tibble(
adj_R2 = 0,
t_stat = 0,
coef = 0
))
fs_name = trans_df %>% arrange(order, variable) %>% pull(name) %>% unique()
fs = trans_df %>% arrange(order, variable) %>% pull(func) %>% unique()
m = model$model_table[0, ]
# for each combo
for (i in 1:nrow(df)) {
# i = 1
var_t_name = variable
data[, 'temp_var'] = data[, variable]
# for each trans
for (j in 1:length(fs_name)) {
# j = 2
f_name = fs_name[j]
var_t_name = paste0(var_t_name, '_', f_name)
# print(var_t_name)
ps = trans_df %>%
filter(name == f_name) %>%
arrange(variable) %>%
pull(variable)
vals = c()
# for each param
for (p in ps) {
val = df[i, paste0(f_name, '_', p)]
vals = c(vals, val)
var_t_name = paste0(var_t_name, '_', val)
# print(var_t_name)
e <- new.env()
assign(p,val,envir = e)
}
m[1, f_name] = vals %>% paste0(collapse = ',')
f = fs[j]
if (model$normalise_by_pool) {
for (g in groups) {
# g=groups[1]
x = data$temp_var[data[, pool] == g]
x = f %>% run_text(env = e)
data$temp_var[data[, pool] == g] = x
}
} else{
x = data$temp_var
x = f %>% run_text(env = e)
data$temp_var = x
}
}
data[, var_t_name] = data[, 'temp_var']
data[, 'temp_var'] = NULL
# print('_______________')
m[1, 'variable'] = variable
m[1, 'variable_t'] = var_t_name
m = m %>%
zoo::na.fill('') %>%
as.data.frame() %>%
bind_rows(model_table)
ivs_t = m %>% select(variable_t)
# build formula object
formula = build_formula(dv = dv, ivs = ivs_t)# run model
# print(var_t_name %in% colnames(data))
model_temp = lm(formula = formula,
data = data) %>% TRY()
# if model failed
if (is.null(model_temp)) {
# fill row with empty
print(paste0(var_t_name, ' - NOPE'))
# output[i, ] = list(iv, "0",0,0,0,0)
} else{
# get model summary
ms = summary(model_temp)
# generate row
coef = ms$coefficients[var_t_name, "Estimate"] %>%
TRY()
if (is.null(coef)) {
adj_R2 = 0
t_stat = 0
coef = 0
} else{
adj_R2 = ms$adj.r.squared
t_stat = ms$coefficients[var_t_name, "t value"]
}
df$adj_R2[i] = adj_R2
df$t_stat[i] = t_stat
df$coef[i] = coef
}
}
i = 1
var_t_name = variable
var_t_name
data[, 'temp_var'] = data[, variable]
j = 2
f_name = fs_name[j]
var_t_name = paste0(var_t_name, '_', f_name)
ps = trans_df %>%
filter(name == f_name) %>%
arrange(variable) %>%
pull(variable)
vals = c()
p = ps[1]
val = df[i, paste0(f_name, '_', p)]
val
i
paste0(f_name, '_', p)
f_name
fs_name
j = 1
f_name = fs_name[j]
var_t_name = paste0(var_t_name, '_', f_name)
ps = trans_df %>%
filter(name == f_name) %>%
arrange(variable) %>%
pull(variable)
vals = c()
val = df[i, paste0(f_name, '_', p)]
val
f_name
p
ps
p = ps[1]
p
val = df[i, paste0(f_name, '_', p)]
val
vals
vals = c(vals, val)
vals
var_t_name = paste0(var_t_name, '_', val)
var_t_name
var_t_name
var_t_name = variable
var_t_name = paste0(var_t_name, '_', f_name)
var_t_name
var_t_name = paste0(var_t_name, '_', val)
var_t_name
# print(var_t_name)
e <- new.env()
assign(p,val,envir = e)
p
a
# for each param
for (p in ps) {
val = df[i, paste0(f_name, '_', p)]
vals = c(vals, val)
var_t_name = paste0(var_t_name, '_', val)
# print(var_t_name)
e <- new.env()
assign(p,val,envir = e)
}
var_t_name = variable
data[, 'temp_var'] = data[, variable]
f_name = fs_name[j]
var_t_name = paste0(var_t_name, '_', f_name)
ps = trans_df %>%
filter(name == f_name) %>%
arrange(variable) %>%
pull(variable)
vals = c()
# for each param
for (p in ps) {
val = df[i, paste0(f_name, '_', p)]
vals = c(vals, val)
var_t_name = paste0(var_t_name, '_', val)
# print(var_t_name)
e <- new.env()
assign(p,val,envir = e)
}
m
m[1, f_name] = vals %>% paste0(collapse = ',')
m
f = fs[j]
f
e
e()
model$normalise_by_pool
x = data$temp_var
x = f %>% run_text(env = e)
e
run_text
eval(parse(text = f), envir = e)
e = new.env()
ls(envir = e)
# for each param
for (p in ps) {
val = df[i, paste0(f_name, '_', p)]
vals = c(vals, val)
var_t_name = paste0(var_t_name, '_', val)
# print(var_t_name)
e <- new.env()
assign(p,val,envir = e)
}
ls(envir = e)
e <- new.env()
# for each param
for (p in ps) {
val = df[i, paste0(f_name, '_', p)]
vals = c(vals, val)
var_t_name = paste0(var_t_name, '_', val)
# print(var_t_name)
assign(p,val,envir = e)
}
m[1, f_name] = vals %>% paste0(collapse = ',')
f = fs[j]
if (model$normalise_by_pool) {
for (g in groups) {
# g=groups[1]
x = data$temp_var[data[, pool] == g]
x = f %>% run_text(env = e)
data$temp_var[data[, pool] == g] = x
}
} else{
x = data$temp_var
x = f %>% run_text(env = e)
data$temp_var = x
}
# for each trans
for (j in 1:length(fs_name)) {
# j = 1
f_name = fs_name[j]
var_t_name = paste0(var_t_name, '_', f_name)
# print(var_t_name)
ps = trans_df %>%
filter(name == f_name) %>%
arrange(variable) %>%
pull(variable)
vals = c()
e <- new.env()
# for each param
for (p in ps) {
val = df[i, paste0(f_name, '_', p)]
vals = c(vals, val)
var_t_name = paste0(var_t_name, '_', val)
# print(var_t_name)
assign(p,val,envir = e)
}
m[1, f_name] = vals %>% paste0(collapse = ',')
f = fs[j]
if (model$normalise_by_pool) {
for (g in groups) {
# g=groups[1]
x = data$temp_var[data[, pool] == g]
x = f %>% run_text(env = e)
data$temp_var[data[, pool] == g] = x
}
} else{
x = data$temp_var
x = f %>% run_text(env = e)
data$temp_var = x
}
}
library(devtools)
check()
submit_cran()
submit_cran()
submit_cran()
?inherits()
m = lm(formula = mpg~cyl,data = mtcars)
m
inherits(m)
is(m)
is(m,class2 = 'lm')
!is(m,class2 = 'lm')
submit_cran()
submit_cran()
